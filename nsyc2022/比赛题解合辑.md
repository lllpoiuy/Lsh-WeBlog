# SYC2022 比赛题解合辑（Day 1~5）

### Day 1 T1 求和

> 给定数组 $A$，函数 $T(A)$ 会返回一个新数组，函数 $T$ 如下所示：
>
> ```cpp
> vector <int> T(vector<int> A){
>     vector <int> B;
>     int n=A.size(), i, j, k;
>     for (i=0; i<n; i++){
>         for (j=0; j+i<n; j++){
>             int mx=A[j];
>             for (k=j; k<=i+j; k++) mx=max(mx, A[k]);
>             B.push_back(mx);
>         }
>     }
>     return B;
> }
> ```
>
> 你的任务很简单——求 $T(T(A))$ 的所有元素之和，答案对 $10^9+7$ 取模输出。$n\le 10^5$。

### Day 1 T2 游戏

> Alice 和 Bob 正在玩游戏，游戏规则如下——
>
> 给定一个长度为 $n$ 的字符串，每次操作只能为以下二者之一：
>
> 1. 删去一个字符。
>
> 2. 将当前字符串打乱，重新排列为此前没有出现过的一个新字符串。
>
> Alice 先手，首先删完字符串的人获胜，两人都绝顶聪明，会按照最优策略行动。
>
> Bob 觉得这游戏对自己很不公平，于是他想知道，假设字符串的所有字符均选自集合 $\{1,2,...,k\}$，总共有多少种字符串能够使自己获胜？
>
> 答案对 $19260817$ 取模后输出（这是一个质数）。

经过艰苦卓绝的打表，我们发现先手几乎是必胜的。只有一种情况下后手可以翻盘，那就是初始的字符串的可重排列数是一个奇数。我们使用归纳法证明：

1. 若当前字符串的排列种类数为奇数，那么由于可重排列的性质，任意删去一个字符产生的新字符串排列数都是偶数，即递归意义上的必胜态；所以不管是先后手，其目标都是不删数。但是由于总数是奇数，所以先手不得不去删数，从而使得后手进入了必胜态。
2. 若当前字符串的排列数是偶数，继续分类讨论：若存在一个字符使得删掉后是一个必败态，那么作为先手肯定会抢先删掉那个字符；若不存在，则双方都会去极力避免进入后继状态，而后手由于奇偶性会被迫进入。

继续观察这张表或者分析可重排列的性质可以发现，当 $n$ 为奇数时无解；当 $n$ 为偶数时，后手必胜的字符串一一对应于把 $n$ 划分成若干个整数 $a_i$，使得它们两两的交为 $0$ 且总的并等于 $n$，形如 $a_1$ 个 `a`、$a_2$ 个 `b`……这样的一个字符串就是合法的。

我们列出单种字母的 EGF 为 $f(x)=\sum_{s} x^s\cdot \frac 1{s!}$。其中的 $s!$ 用于计算在排列这 $n$ 个字符时的可重排列。我们要求的就是 $f^n(x)$。（在不交并卷积的意义下）。

直接暴力快速幂是 $\log^3$ 的。我们将其列成占位多项式，然后利用 $g=f^n$ 两边同时求导求得递推式的经典 Trick 即可做到 $n\log^2{n}$。

事实上，优美的暴力 dp 是 $O(n^{1.58})$ 的（即 $O(3^{\log_2{n}})$）。

### Day 1 T3 染色

> 给定一个 $n$ 个节点，$n-1$ 条边的有向图，总共有 $m$ 种颜色，每个节点都有一个颜色 $col_i(1 \le col_i \le m)$，且对于任意满足 $2 \le i \le n$ 的节点 $i$，有一条由 $i$ 指向 $p_i (1\le p_i <  i)$ 且长度为 $1$ 的有向边。
>
> 给定 $q$ 组询问，对于每组询问，给定 $t$ 个人以及他们所在的初始节点 $v_1,v_2,...,v_t$（可能有重复），每个人手中都有一个无限大的调色板，他们将在满足每个人都走最短路径的情况下总长度最少的节点集合（如有多个，选择编号最小的那个），每个人可以选择任意一条最短路径前往集合节点，在路径上途经的所有节点中，他们可以自由地选择是否将该节点的颜色加入自己的调色板（每种颜色最多允许加入 $1$ 次），但是，为了拒绝内卷，他们约定，到达集合节点后，每个人的调色板上颜色数量应当相同；同时，为了避免重复劳动，他们还约定，任意两个人的调色板上不能有相同颜色。
>
> 他们非常团结、也非常聪明，希望最大化集合后的颜色数量总和，并且一定能按照最优策略行动，请问他们最终总共能获得多少种不同的颜色？$1 \le n \le 300000,1 \le m \le 1000,1 \le q \le 50000,2 \le t \le 5$。

显然集合点就是集合内所有点的 LCA。首先我们必然是得提取出每个点到 LCA 的路径上有哪些颜色，倍增并维护 bitset 即可（为了防止空间超限，可以离线下来，所有的一起倍增，空间上会少一个 $\log$）。

对于每次询问，二分每个人能拿多少颜色，check 时会列出一个最大流的形式，源点连向每个人，每个人连向每种颜色，颜色连向汇点（压缩了左部点的二分图匹配）。直接 `Hall` 定理，复杂度 $\frac 1w \cdot \log{n}\cdot q\cdot 2^t\cdot m$。由于每次 bitset   计算出来的结果是一样的，所以可以再少一个二分。

这启示我们，OI 做题中不能过度依赖题目性质，在合适的时候就应该诉诸工业解法。工业解法和思维解法必须两者同时灵活运用，且训练上要达到一种平衡。

### Day 2 T1

> 有 $n$ 个随从站成一排，第 $i$ 个随从的攻击力为 $a_i$，血量为 $h_i$。每个随从还会使它左右相邻随从的攻击力提供 $b_i$。
>
> 你的攻击力为 $m$，每次你可以选择一只活着的随从进行攻击，使其血量减少 $m$。如果其血量小于等于 $0$，则它死亡，并且它两边的随从会靠在一起成为相邻关系。
>
> 在你攻击第 $i$ 个随从时，你不仅会受到 $a_i$ 点伤害，还要额外承受其相邻随从的提高攻击值 $b_{i−1}+b_{i+1}$ 点伤害（如果它们存在）。求你最少受到多少点伤害可以消灭所有随从。$n\le 400$。

显然 $a$ 是没有作用的，且每次一定是把一个人彻底杀死再进攻下一个目标。我们枚举最后一个删掉的到底是哪一个点，递归进左区间和右区间，以左区间为例，则它始终有一个来自于最右边的 $b_{mid}$ 的额外攻击。直接区间 dp 即可。

### Day 2 T2

> 给定 $n,m$，求有多少长度为 $2m$ 的序列 $a$ 满足：
>
> $$∀1≤i≤2m,a_i∣n$$
>
> $$\prod^{2m}_{i=1}a_i≤n^m$$
>
> 答案对 $998244353$ 取模。$1≤n≤10^9,1≤m≤100$。

$2m$ 的作用究竟是什么呢？我们注意到大于等于 $n^m$ 的问题和原问题是对称的，因为 $\prod \frac n{a_i}\ge n^m$。因此实际上只需要计算乘积等于 $n^m$ 的方案数即可。

显然每个质因数是彼此独立的，而每个质因数就相当于是把一些相同的物品分给有编号的人，且每个人有个背包大小上限。直接容斥，枚举有多少人超出上界即可。

### Day 2 T3

> 定义对 $k$ 个长度为 $n$ 的序列的归并为：
>
> 维护一个空序列 $A$，执行下列操作 $kn$ 次: 选择一个非空序列，将其第一个数取出，放入 $A$ 的末尾。
>
> 两个归并不同，当且仅当存在某次操作，选取的序列标号不同。
>
> 一个归并被称为是合法的，当且仅当最终序列 $A$ 中不存在一个长度为 $k$ 的子串，使得这个子串中的数为同一个数。
>
> 给定 $m$ 个长度为 $n$ 的排列，定义 $f(l,r)$ 表示只考虑 $[l,r]$ 中的排列不同的合法归并方法数，求 $\sum^{m}_{i=1}\sum^m_{j=i+1}f(i,j)$ 模 $998244353$ 的值。
>
> **保证测试数据随机生成。**$1≤n,m≤300$。

对于固定的 $(i,j)$，我们枚举哪些颜色构成不合法，进行一个服从子集反演的容斥。显然这些颜色必须满足彼此的相对位置相同；计算方案时，在两个颜色间的部分构成一个可重排列，直接计算即可。

对于 $j-i\ge 30$ 的情况，出现超过一种颜色不合法的概率微乎其微，因此直接枚举是哪种颜色不合法，结合前缀和优化即可做到 $O(n^3)$。

对于 $j-i+1\in[5,30]$ 的情况，我们直接 dfs 这个不合法的颜色序列，使用 bitset 进行剪枝，实测可以跑在 $1s$ 左右。

对于 $j-i+1\in [2,4]$ 的情况，我们发现颜色的相对关系必然可以由第一个排列直接决定。设 $f_j$ 表示以颜色 $j$ 结尾的考虑容斥系数的方案数，那么可以 $O(m^3\cdot C)$ 完成这一部分。

事实上 std 的做法非常简洁，把上述第三部分的 dp 改成固定左端点右移右端点，剪枝掉已经没用的 $j$。

### Day 3 T1

>有一个随机变量 $z$，初始 $z=0$。
>
>执行 $n$ 次操作：每次操作是从 $0$ 到 $k$ 中以 $p_t$ 的概率选择一个整数 $t$，并令 $z:= z+t$。
>
>求 $\min(z, x)$ 的期望。答案模 $998244353$。$1\le n\le 10^7, 1\le k\le 100, 1\le x\le \min(10^7, \frac{5\times 10^7}{k}), 1\le a_i\le 100$。

见 https://lllpoiuy.github.io/Lsh-WeBlog/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F.html 中的 Example 12。

### Day 3 T2

> 你要生成一个长度为 $n$ 的数列，有 $m$ 个可行数对，每个可行数对 $(a_i, b_i)$ 表示 $b_i$ 这个数能放在 $a_i$ 这个位置上。已知这 $m$ 个可行数对能生成出的排列数量是奇数，对于每个可行数对，你想知道如果删掉它，剩下的可行数对能生成的排列数量是否还是奇数。$1\le n\le 2000, 1\le m\le \min(n^2, 5\times 10^5), 1\le a_i, b_i\le n$，所有可行数对互不相同。

考虑这个矩阵的行列式，每种排列都会贡献 $1$ 或 $-1$，所以行列式和排列数量奇偶性相同。而只考虑奇偶性的情况下，我们做 $\bmod 2$ 意义下的高斯消元，行列式只能为 $1$ 或 $0$；由题目中的条件就得到矩阵满秩。

题目就变成了看修改单点后矩阵是否还满秩，用线段树分治求出除了一个向量之外所有向量的线性基，再看能否表出经过修改的那个向量。复杂度 $O\left(\frac 1w\cdot n^3\log{n}\right)$。

更快的做法是：考虑经过一个点的排列的数量，也就是代数余子式 $M_{i,j}$ 的求法。而伴随矩阵就等于代数余子式构成的矩阵的转置，满足：
$$
\operatorname{adj}(A)=\det(A)\times A^{-1}
$$
因此直接矩阵求逆就可以做到 $O(\frac 1w\cdot n^3)$ 的复杂度。

### Day 3 T3

> 世界杯小组赛就要结束了，这是 $\text{Y}$ 国队的生死战，他们只有获得胜利才能出线。
>
> 由于这只队伍是一只很迷的队伍，所以对于队中的所有 $n$ 个队员，第 $i$ 个队员这场能够发挥的实力是一个 $\left[0,a_i\right]$ 中的随机实数。不过这只队伍的配合很好，如果最终第 $i$ 个队员发挥出了 $x_i$ 的实力，那么这支队伍的战力就是 $\left(\sum_{i=1}^n x_i\right)^m$ 。现在球队的主教练 $\text{Y}$ 夫希望能够计算出这场比赛他们期望下能够发挥出多少的战力。
>
> 为了避免精度误差，请输出答案在模 $998244353$ 下的值。$n,m\leq 10^5$。

假设我们能把式子展开来，对于其中形如 $\prod_{i=1}^n x_i^{a_i}$ 的一项（$\sum a_i=m$），它的贡献是 $\prod\limits_{i=0}^n\frac {a_i^{b_i}}{b_i+1}\cdot \frac 1{b_i!}$，前半部分是积分的结果，后半部分是可重排列的一部分。

为了快速统计，我们将其写作生成函数的形式：
$$
m![x^m]\prod\limits_{i=1}^n\left(\sum\limits_{j=0}^n{\frac {a_i^j\cdot x^j}{(j+1)!}}\right)=m![x^m]\operatorname{exp}\left( \sum_{i=1}^n\ln\left( \sum_{j=0}^n\frac{a_i^jx^j}{(j+1)!} \right)  \right)
$$
到这里看上去已经很难优化，我们把 $\ln\left( \sum_{j=0}^n\frac{x^j}{(j+1)!} \right)=\sum_{i=0}^mp_i\cdot x^i$ 预处理出来，然后问题就变成了求 $p_i$ 的每一项后面乘的是什么，也就是所有 $a_j$ 的 $i$ 次方和。

这就是一个经典问题了，答案的 OGF 显然为 $\sum_{i=1}^n\frac 1{1-a_ix}$。可以分治地通分并求和。

### Day 4 T1

> 定义函数 $F(x)$ 表示 $x$ 的不同质因子数量，例如，$F(6)=2$，$F(8)=1$（$6$ 有质因子 $2,3$，$8$ 只有质因子 $2$）。
>
> 给定长度为 $n$ $(1 \le n \le 10^5)$ 的数组 $A=\{A_1,A_2,...,A_n\}$ ，其中数组内元素均为不超过 $10^7$ 的正整数。
>
> 你需要回答 $q$ 次询问，每次询问给定 $L,R$，求 $\sum_{i=L}^{R} \sum_{j=i+1}^{R} F(\gcd(A_i,A_j))$。
>
> 其中，$\gcd(a,b)$ 表示正整数 $a,b$ 的最大公约数。$1 \le n \le 100000, 1 \le q \le 100000, 1 \le x \le 10^7$。

考虑对每个素因子分别考虑，设素数 $i$ 在区间中出现了 $cnt_i$ 次，那么贡献就是 $\frac 12 cnt_i\cdot (cnt_i-1)$。直接莫队，$O(n^{1.5}\cdot \omega(V))$ 维护即可。

### Day 4 T2

> A 国有 $n(1 \le n \le 10^5)$ 个城市，初始条件下两两之间修建道路（道路均为无向边）的代价均为 $0$。
>
> 修建道路的代价会不断更新，按照时间先后顺序，总共有 $m(1 \le m \le 10^5)$ 次更新 ——
>
> 每次更新由形如 $x_1,x_2,y_1,y_2,w(1 \le x_1 \le x_2 \le n, 1 \le y_1 \le y_2 \le n,-10^6 \le w \le 10^6)$ 的五个参数表示,
>
> 其中，对于所有满足 $x_1 \le i \le x_2, y_1 \le j \le y_2$ 的点对 $(i,j)$，连接 $i$ 号城市和 $j$ 号城市的代价会增加 $w$（注意，如果点对 $(i,j),(j,i)$ 均满足条件，这条道路的修建代价会增加 $2w$），在所有更新结束后，询问 —— 在最小化所修道路数量的基础上，能够保证 A 国任意两个城市可以互相到达的最小总代价是多少？
>
> 每个测试点有多组数据。

相当于对权值进行平面加，然后求最小生成树。这种奇形怪状的 MST 当然是用 B 算法来解决，每轮迭代都对平面从左到右进行一次扫描线，以维护出每条边的权值。而 B 算法又要求出不在本连通块中的最小边，那么就在线段树上维护标号不同的最大值和次大值即可。$O(n\log^2{n})$。

B 算法的精髓就在于可以放心的重构，重构的过程中可以承载大量信息；而处理标号不同的最经典方式就是维护最大值和次大值。

### Day 4 T3

> Alice 想给 Bob 传递一个长度为 $n$ 的 01 串 $c=c_1c_2....c_n$，因为担心被窃听，因此对信息进行了加密，加密方式如下 ——
>
> Alice 首先选择出 $n$ 个正整数 $a_1,a_2,...a_n$，对于任意 $i$ 均满足 $a_i > \sum_{j=1}^{i-1} a_{j}$，且 $\sum_{i=1}^{n} a_i < q = 2^{64}$。
>
> 接下来，Alice 随机生成一个奇数 $r$，构造出数列 $b_1,b_2...b_n$，满足 $b_i \equiv a_i \times r \pmod{q}$。
>
> 最后，Alice 将 $b_1,b_2,...b_n$ 以及 $\sum_{i=1}^{n} b_{i}c_{i} \pmod{q}$ 的值发给了 Bob，并声称 Bob 能够根据这些信息还原出原 01 串 $c=c_1c_2....c_n$。
>
> Bob 发现自己并不会还原，于是向你求助。

### Day 5 T1

> 我们定义仙人掌为任何一条边至多在一个简单环内的简单连通图。
>
> 对于一棵 $n$ 个点的仙人掌，我们定义 $f(l,r)$ 为只保留编号位于 $[l,r]$ 之间的点的时候，形成的连通块数量。你需要求出下面这个式子：
>
> $$
> \sum_{i=1}^n\sum_{j=i}^n f^k(i,j)
> $$
>
> 虽然答案不会很大，但为了让它看起来更像一个计数题，你还是要输出答案对 $10^9+9$ 取模后的值。$1\leq n\leq 200000,k\in\{1,2\}$。

对于 $k=1$，仙人掌上也可以像树一样，选取代表点，并统计每个代表点在多少个区间中出现。第一优先取连通块中深度最小的，第二优先取最顶上的环上最靠左的。我们惊奇地发现每个点作为代表点的区间一定还是 $l\in [a,b],r\in[c,d]$ 的所有 $[l,r]$ 的形式，可以用 `set` 预处理出来。

对于 $k=2$，如果我们能知道每个 $[l,r]$ 的连通块数，则可以直接平方并求和；为了快速统计，我们扫描线，将 $k=1$ 时预处理出来矩形加在扫描线中拿出来用。这个线段树需要支持区间加和区间求平方和，再记一个区间和作为辅助即可。$O(n\log{n})$。

### Day 5 T2

> 这是一道构造题。
>
> 从前，有两个神奇的数字 $n$ 和 $k$。现在，你希望构造一个 $n$ 个点的简单图，其中每个点的度数都至少是 $k$。这个问题太过于简单了，于是你还希望图中所有度数为 $k$ 的点均不相邻；在满足上述要求的情况下，你还想让总边数最小。$2\leqslant k\leqslant 10,2k+1\leqslant n\leqslant 1000$。
>

我们枚举有多少个点度数为 $k$，设其为 $a$，则剩下有 $b=n-a$ 个点度数为 $k+1$，此时边数为 $ak+\frac 12 (b(k+1)-ak)$，求这个函数的最小值即可。构造方案由于 `Erdős–Gallai` 定理而必定存在。

**Havel–Hakimi 算法**：不增的度数序列 $(d_1,d_2,\cdots,d_n)$ 可简单图化当且仅当度数序列 $(d_2-1,d_3-1,\cdots,d_{d_1+1}-1,d_{d_1+2},d_{d_1+3},\cdots,d_n)$ 可简单图化，即可递归构造。

**Erdős–Gallai 定理**：非递增度数序列 $d$ 可简单图化当且仅当 $\sum d$ 是偶数且
$$
\forall k\in[1,n],\sum_{i=1}^kd_i≤k(k−1)+\sum_{i=k+1}^n\min(d_i,k)
$$
根据这个定理，先把 $ak$ 条边尽可能平均分配后，上面那个构造必然是有解的。（即我最早写的贪心其实是正确的，但毕竟后来用 dp 水过去了嘛）。

### Day 5 T3

> 对于一个 $B$ 进制数 $x=\sum x_iB^i$，我们定义它的数根 $r(x)$ 如下：
>
> $$
> r(x)=\begin{cases}x&x<B\\\sum\limits_{i=1}x_i&x\ge B\end{cases}
> $$
>
> 如：$r(abcd_{16})=r(2e_{16})=r(10_{16})=1_{16}$。
>
> 现在你有一个长度为 $n$ 的 $B$ 进制串 $s$，每次给定一个集合 $A$ 和一个数 $x$，你需要回答有多少个 $s[l\ldots r]$ 可以通过将至多一个字符更改为 $A$ 中的元素使得数根为 $x$。$1\leq n,m\leq 2^{19},2\leq B\leq 16,0\leq x< B$。

我们惊奇地发现：$r(x)=x\bmod (B-1)$。但是对于 $r(x)=0$ 和 $r(x)=B-1$ 的情况难以区分，当且仅当整个区间本来就是 $0$ 时 $r(x)=0$，这个情况可以单独处理，我们忽略。

考虑一个区间带有哪些有用的信息？$\bmod (B-1)$ 下的区间和、区间中出现过哪些数字。看似本质不同的区间数是 $O(B\cdot 2^{B})$ 的；但实际上，对于固定的 $r$，区间中出现的数字不同的 $l$ 本质上只有 $B$ 个。所以我们记下每个元素上次出现是在什么时候，并在线地维护 $s_{r,i,j}$ 表示以 $r$ 为右端点的、前面有 $i$ 种数字的、区间和为 $j$ 的区间有多少个。$r$ 右移会合并两个 $s_{r,i}$ 并新建一个块。暴力维护便是 $O(nB^2)$ 的。

统计完区间，我们直接高维前缀和一下便能快速回答答案了。