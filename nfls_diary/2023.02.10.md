### 简单序列题

> ![](./p31.png)
>
> $n\le 100000$。

我们发现每次都是操作最大值 $a_i$，如果 $a_{i-1}\ge a_{i-1}$，那么操作 $(i-1,i)$；否则操作 $(i,i+1)$。用个堆和并查集维护就好了。

### 简单打怪题

> ![](./p32.png)
>
> $n\le 100,m\le 5\times 10^4$。

注意到 Johnson 序需要记两个信息，从前往后做的话，能做，但是需要一个二分。

但是**从后往前做，只需要记一个最小值就行了**，不需要记总和！所以设 $f_{i,j}$ 表示 $i$ 之后的层，当前等级是 $j$，需要的最小初始等级。这个转移是可以决策单调性分治优化的。

### 简单判断题

> ![](./p33.png)
>
> $n,m\le 2\times 10^5$。

首先肯定是 $2$ 的倍数。先随便找到一个生成树，如果它符合条件就好；不符合，我们就找一条非树边替换进去，如果存在一条对应的树边替换后效果很好，那就好了！所以我们随机一些生成树并枚举树边来判断就行了。

### Doremy's Paint 2

> 给定一个长度为 $n$ 的序列 $a_{1\cdots n}$，初始有 $a_i=i$。
>
> 现在有 $m$ 个操作，第 $i$ 个操作有参数 $l_i,r_i(l_i\le r_i)$，执行该操作会把 $a_{l_i+1\cdots r_i}$ 赋值为 $a_l$。
>
> 给定 $k$，对于所有 $x=1\sim m$，求如果依次执行第 $x$ 个到第 $x+k-1$ 个操作那么序列中有多少种不同的元素。这里将第 $i+m$ 个操作视为第 $i$ 个操作。$n,m\le 10^5$。

我们从后往前推，维护 $f_i$ 表示 $i$ 元素能生存到什么时间。那么一个 $t$ 时刻的操作 $[L,R]$ 相当于令：
$$
\forall i\in(L,R],a_i\leftarrow t\\
a_L\leftarrow \max_{j\in[L,R]}a_j
$$
发现 $f$ 的连续段个数的总和只有 $O(n)$ 级别，所以我们可以用 set 来暴力维护这些连续段。在维护 set 的同时，维护一个树状数组，维护每个时间消失的元素个数，就能在树状数组上 $O(\log n)$ 进行一次查询了。

### Fishermen

> 给你一个长度为 $n$ 的序列 $\{a\}$，你可以将 $\{a\}$ 中的数重新排列，并根据重排后的序列 $\{a\}$ 生成序列 $\{b\}$，生成方法如下：
>
> - $b_1=a_1$。
>
> - $\forall i\in(1,n]$，$b_i$ 是满足 $a_i|b_i$ 且 $b_i>b_{i-1}$ 的的小正整数。
>
> 求所以可能生成的序列 $\{b\}$ 中 $\sum\limits_{i=1}^nb_i$ 的最小值。$n\le 1000$。

找一个数组 $c_{1\sim n}$，使得 $b_i=c_ia_i$ 两两不同，那么肯定存在一个顺序使得 $b$ 严格递增，代价也就是 $\sum c_ia_i$。

对于每个 $a_i$ 枚举 $a_i\sim na_i$，分别建一个左部点，连向右部点 $i$。那么这张图的最小费用最大匹配就是答案。

考虑右部点数只有 $n$，所以我们可以在每次产生新增广路后（这只会发生 $n$ 次），从汇点进行一次 bfs $\mathcal{O}(n^2)$，处理出所有能到达汇点的右部点；从小到大考虑这 $\mathcal{O}(n^2)$ 个左部点时，只要 $\mathcal{O}(1)$ 判断它连向的点是不是可以到达汇点就行了。总复杂度 $\mathcal{O}(n^3)$，可以用 bitset 优化掉一个 $w$。