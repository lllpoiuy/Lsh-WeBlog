### [[WTF2019E]. e](https://atcoder.jp/contests/wtf19/tasks/wtf19_e)

#### 题意：

> 有一个有 $n$ 个位置的长椅，每个人对座位的要求是左边相邻的位置和右边相邻的位置都是空的，且会从满足要求的位置里随机选择一个。人们依次随机入座，直到坐不下为止。给定字符串 $S$ 形如 `X--X-X-X--X-X`，其中 `X` 表示此位置被人占有，`-` 表示该位置不被占有。设 $f(n,S)$ 表示 $n$ 个位置的长椅被随机入座到没有新的可以入座的位置时，$S$ 在入座情况序列中的 $|\mathrm{endpos}|$ 的期望。求 $\lim_{n\rightarrow+\infty}{\frac{f(n,S)}n}$。
>
> 设答案为 $p+\frac qe +\frac{r}{e^2}$，请输出 $p,q,r$ 对 $998244353$ 取模后的结果。$|S|\le 1000$。

#### 题解：

首先，考虑计算 $S=X$ 时的答案，即计算一个位置被占有的概率。不妨将随机过程重新描述为：随机 $n$ 个 $[0,1]$ 之间的实数 $x_{1\sim n}$，按照 $x_i$ 从小到大的顺序依次考虑每个 $i$，若 $i-1$ 和 $i+1$ 都没有人，则向 $i$ 处放一个人。

现在再来计算一个位置被占有的概率，就不需要去考虑时效性的问题，只需转而考虑 $x$ 序列上的问题。不难发现，$i$ 能被占有，当且仅当 $x_i$ 左侧的极长上升子串的长度为偶数，且 $x_i$ 右侧的极长下降字串的长度为偶数。而左侧为偶数的概率和右侧为偶数的概率彼此独立，我们不妨单独计算左侧为偶数的概率，容斥一下：
$$
\begin{equation}\begin{aligned}
f(x_i)&=1-P(x_{i-1}<x_i)+P(x_{i-2}<x_{i-1}<x_{i})-P(x_{i-3}<x_{i-2}<x_{i-1}<x_{i})+\cdots\\
&=1-x_i+\frac{x_i^2}{2!}-\frac{x_i^3}{3!}+\cdots\\
&=e^{-x_i}
\end{aligned}\end{equation}
$$
所以 $\lim_{n\rightarrow+\infty}{\frac{f(n,X)}n}=\int_{0}^1e^{-2x}dx=\frac 12-\frac 1{2e^2}$。

根据上面的启发，我们可以设计一个 $dp_i$，每个 $dp_i$ 值存下一个关于 $x_i$ 的函数，表示满足若干条件的以 $\mathrm{const\ } x_i$ 结尾的概率是多少。不难发现只需要用一个 `bool` 记录下左边的奇偶性，一个 `bool` 记录下右边下降段延伸奇数个是否合法，一个 `bool` 记录下右边下降段延伸偶数个是否合法。而每个 $dp$ 值都可以表示为一个函数 $P(x)+\frac{Q(x)}e+k\cdot e^{-x}$。复杂度 $O(|S|^2)$。

### [[AGC056 E] Cheese](https://atcoder.jp/contests/agc056/tasks/agc056_e)

#### 题意：

> 有一个长度为 $n$ 的环，将其上的坐标记为 $[0,n)$。$\forall i\in[0,n)$，有一个老鼠位于 $i+0.5$ 位置上。接下来有 $n-1$ 的奶酪，依次以 $\frac{A_i}{\sum A_i}$ 的概率出现在位置 $i$，对于每只奶酪，生成后开始向 $x$ 增大的方向走，当遇到一只没吃过奶酪的老鼠时，以 $\frac 12$ 的概率被这只老鼠吃掉。直到被吃掉后，再生成新的奶酪。问每只老鼠最后饿肚子的概率。$n\le 40$。

#### 题解：

直接做的话会发现，绕不开一个对状态 / 出现顺序之类的东西的枚举。然后陷入困境……这是做这类描述一个随机过程的题的常见经历。类似上一题，**我们重新刻画这个随机的过程，使得这个过程可以拆分或者可以更好地描述**。（下面的内容参考了 OneInDark）。

把每只奶酪的活动过程分解为多个判定：
$$
\operatorname{check}(cheese_i,mouse_i)=
\left\{
\begin{aligned}
&\mathrm{probability}\frac 12 \rightarrow Eat\ it!\\
&\mathrm{probability}\frac 12 \rightarrow \operatorname{check}(cheese_i,mouse_{i+1})
\end{aligned}
\right.
$$
我们不妨把这个递归的规程用栈来存储，而可以发现，$\operatorname{check}(x,y_1)$ 和 $\operatorname{check}(x,y_2)$ 之间的执行顺序有关系，但是 $\operatorname{check}(x_1,y)$ 和 $\operatorname{check}(x_2,y)$ 之间的顺序完全没有关系——因为大可以交换这两个 $cheese$。

所以不妨可以从位置 $i$ 开始，记一个 $dp[][][]$ 存下当前判定的老鼠、一共生成了多少个奶酪、一个吃了多少奶酪，其中第二维上要乘上一个可重排列。然后一直转移到 $dp[i-1][][]$，然后就能用一个类似解方程形式的东西算出第 $i$ 只老鼠饿肚子的概率。复杂度 $O(N\cdot N^4)$。

### [[CF1685E] The Ultimate LIS Problem](https://codeforces.com/problemset/problem/1685/E)

#### 题意：

> 给定一个长度为 $2n+1$ 的排列，$q$ 次修改形如交换其中的两个数。对于每次修改后产生的排列，输出一个 $k$ 表示循环位移 $k$ 位后这个排列的 $LIS$ 长度小于等于 $n$，当不存在时 $k=-1$。$n\le 10^5$。

#### 题解：

乍看很不科学，但是一个思路是：试一试一些的构造，对于这个构造下合法的就直接输出，否则以其不合法条件为新增的前提条件，继续做一道弱化版的本题，知道条件足够强为止。

我们把 $n+1$ 视作 $0$，大于 $n+1$ 的视作 $1$，其它视作 $-1$，那么取前缀和最小的那个位置作循环位移。容易发现，若 $LIS$ 长度 $\ge n+1$ 时，$n+1$ 必选，否则可以推导出有 $n+1$ 个 $1$ 的结论，就矛盾了。

这个循环位移下，$LIS$ 最长为 $n+1$，且能达到 $n+1$ 的必要条件是 $n+1$ 左侧的前缀和等于零且右侧的和也等于零。还有一个必要条件是，左侧的所有小于 $n+1$ 的数递增且右侧所有大于 $n+1$ 的数递增。那么不难发现，以 $n+1$ 为开始的循环位移和以 $n+1$ 为结尾的循环位移存在解的条件严格比当前循环位移存在解的条件严苛。所以不妨再维护一下当前序列中是否存在子序列 $1,2,\cdots,n+1$ 和 $n+1,n+2,\cdots,2n+1$。$O(n\log n)$。

### [[CF1458F] Range Diameter Sum](https://codeforces.com/problemset/problem/1458/F)

#### 题意：

> 给定一棵 $n$ 个点的边长为 $1$ 的树，求 $\sum_{l< r}\max_{l\le u<v\le r}{\operatorname{dis}(u,v)}$。$n\le 10^5$。

#### 题解：

对于区间直径问题，定义树上圆 $(O,r)$，表示以 $O$ 点为圆心、$r$ 为半径的一个树上圆覆盖。为了避免圆心出现在边中点的情况，令每条边的中间都加一个虚点。

求 $\max_{u,v\in S}\operatorname{dis}(u,v)$ 相当于求一个点集 $S$ 的最小圆覆盖。而这个最小圆覆盖有着平面最小圆覆盖所没有的封闭性：设 $c(S)$ 为 $S$ 的最小圆覆盖，则 $T\subseteq c(S)\Rightarrow c(T)\subseteq c(S)$。所以可以以任意一个顺序进行最小覆盖圆的合并从而求出直径。不难定义最小覆盖圆的加法：
$$
\odot (O_1,r_1)+\odot(O_2,r_2)=
\left\{
\begin{aligned}
&(O_2,r_2) &(O_1O_2+r_1\le r_2)\\
&(O_1,r_1) &(O_1O_2+r_2\le r_1)\\
&\left(\operatorname{go}\left(O_1,O_2,\frac 12(O_1O_2-r_1+ r_2)\right),\frac 12(O_1O_2-r_1+ r_2)\right)&(\mathrm{else})
\end{aligned}
\right.
$$
其中 $\operatorname{go}(u,v,w)$ 表示 $u$ 向 $v$ 走 $w$ 步到达的点。

我们对编号序列分治，每次统计跨过中线的区间的半径的和。处理出前缀和后缀覆盖圆，对于 $\mathrm{const}\ L\in{l,mid}$，$r$ 可以分为 $3$ 类，最左边的一段被 $\odot[L,mid]$ 包含，中间一段需要进行 $\operatorname{go}$ 操作，最右边的一段会包含 $\odot[L,mid]$。双指针一下，问题就变成了求点集 $S$ 到一个点 $u$ 的距离和，用点分树或者全局平衡二叉树维护即可做到总复杂度 $O(n\log^2{n})$。我写了个复杂度为 $O(n\log^3{n})$ 的“不咋平衡二叉树”并拿下最优解。**注：一直以来没有注意的一个细节：`pushup` 之前一定要 `pushdown`**。

### [[CF1672G] Cross Xor](https://codeforces.com/problemset/problem/1672/G)

#### 题意：

> 对于一个 $n\times m$ 的 `01` 矩阵，每次【操作】可以把一个元素 $(i,j)$ 和与它同行或同列的所有格子一起取反。
>
> 给定一个由 `01?` 构成的 $n\times m$ 矩阵，问有多少种将 `?` 替换为 `0` 或 `1` 的方案使得此矩阵可以通过上述操作消成全 `0` 的矩阵。

#### 题解：

不妨设 $n$ 和 $m$ 均为奇数。先解决判定矩阵 $y$ 是否可达的问题：设 $x_{i,j}$ 为 $(i,j)$ 是否经过反色，则可以列出一个 $y$ 关于 $x$ 的方程，每一行是均长为 $n\times m$ 且描述一个十字架的形状，$y$ 可达当且仅当这个方程组有解。而这个方程有解，当且仅当不存在两个“平行”的方程，即不存在一个方程的集合 $S$，使得将 $S$ 内的方程全部相加后，$x$ 的系数全部为 $0$ 且等号右边不等于 $0$。那么我们可以列出所有左侧的和为 $0$ 的集合都提出来作为一个方程，这个方程的秩数显然小于等于 $n\times m$，我们只要找到一个包含其一个基的子集即可。不难发现如下形状的方程组即可满足要求：
$$
0001000\\
0001000\\
1110111\\
0001000\\
0001000\\
0001000\\
0001000
$$
我想到了这一步，但是没有意识到，这个方程组只是相当于限制每一行和每一列的异或和都相等！不妨枚举这个最后等于的这个值为 $X$，那么方程就只有 $n+m$ 个、变量只有 `?` 的个数个了。而我们的目标就是求这个方程的秩——$n+m-$ 异或和为 $0$ 的子集个数取 $\log_2$。所以转而考虑这样的子集的形状——容易发现，**每个变量均恰好存在于两个方程中，那么这两个方程一定同时处于子集中或者子集外**。在这行和列之间连一条边，那么异或和等于 $0$ 的子集个数等于 $2$ 的连通块个数次方。$O(nm)$。

### [[CF1684H] Hard Cut](https://codeforces.com/problemset/problem/1684/H)

#### 题意：

> 求把一个 `01` 串分成若干段，要求每段表示的数的和为 $2$ 的幂（从低到高位）。多测，$\sum n\le 10^6$。

#### 题解：

给人的感觉就是很多个贪心拼起来一定能过，结果写了一个贪心就直接过了。考虑求出 $1$ 的个数，然后从小到大枚举大于等于 $1$ 的个数的 $2$ 的幂，贪心判断是否有解，直到有解为止。不知道为什么评 3400 且 djq 等一众神仙居然没过此题（）。

### [[CF1487E] Become Big For Me](https://codeforces.com/problemset/problem/1687/E)

#### 题意：

> 给定一个实数 $v=1$ 和序列 $a(|a|\le 10^6,a_i\in[1,10^6])$，希望在不超过 $10^5$ 次操作后，将 $v$ 变为 $\gcd \limits_{i \neq j} \{a_i \times a_j\}$。
>
> 在每一次操作中，可以选择序列 $a$ 中的一个子序列 $b(\sum b\le 10^6)$，并且对其做如下两种操作中的一个：
>
> - 放大：令 $v \leftarrow v \times \operatorname{lcm(b)}$；
> - 缩小：令 $v \leftarrow \dfrac{v}{\operatorname{lcm(b)}}$。
>

#### 题解：

首先，题目保证了一定有解，这点很重要。我们只留下每个质因子的次数最小的两个数（一共至多 $14$ 个数）。显然答案不变且一定有解，这就很舒服了。

类似 $\min-\max$ 反演，我们可以得到 $\gcd-\operatorname{lcm}$ 反演：
$$
\gcd(S)=\prod_{T\in S}\operatorname{lcm}(T)^{(-1)^{|T|-1}}\\
\gcd_{i,j\in S}{a_i\cdot a_j}=\prod_{T\in S}\operatorname{lcm}(T)^{(-1)^{|T-1|}+(-1)^{|T|}\cdot(|T|-1)}
$$
于是就解决了。（虽然我觉得比较强凑出来的一道题吧，不够优美）。

### [[CF1687F] Koishi's Unconscious Permutation](https://www.luogu.com.cn/problem/CF1687F)

#### 题意：

> 一个排列是美丽的，当且仅当 $s=\sum \limits_{i=1}^{n-1}[p_i+1=p_{i+1}]$，其中 $[x]=1$ 当且仅当 $x$ 成立。
>
> 对于 $\forall k \in [0,n-1]$，她希望知道有多少个美丽的长度为 $n$ 排列，满足 $k=\sum \limits_{i=1}^{n-1} [p_i<p_{i+1}]$。

#### 题解：

一个想法是捆绑法：把 $s$ 处的相邻的都捆在一起，视作为 $n-s$ 个元素、$\sum_{i=1}^{n-s-1}[p_i<p_{i+1}]=k-s$ 且 $\sum_{i=1}^{n-s-1}[p_i+1=p_i]=0$，最后再乘上一个插板法的 $\pmatrix{s+n-1\\ n-1}$。不妨直接令 $n\leftarrow n-s,k\leftarrow k-s$。

那么直接二项式反演，得到 $\mathrm{Ans}=\sum_{i=0}^{n-1}\pmatrix{n-1\\i}\cdot(-1)^i\cdot\left<\begin{matrix}n-i\\ k-i\end{matrix}\right>$。结合欧拉数的递推式 $\left<\begin{matrix}n\\ k\end{matrix}\right>=(k+1)\cdot \left<\begin{matrix}n-1\\ k\end{matrix}\right>+(n-k)\cdot \left<\begin{matrix}n-1\\ k-1\end{matrix}\right>$ 便得到了 $O(n^2)$ 的做法，然后就是 EI 的事情了，我们凡人就不应该插手。

