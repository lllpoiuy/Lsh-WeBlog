| 编号 | 题目                                                         | 进展                  | done |
| ---- | ------------------------------------------------------------ | --------------------- | ---- |
| 1    | [1383F](https://codeforc.es/problemset/problem/1383/F)       |                       | √    |
| 2    | [1383E](https://codeforc.es/problemset/problem/1383/E)       |                       | √    |
| 3    | [1383D](https://codeforc.es/problemset/problem/1383/D)       |                       | √    |
| 4    | [1383C](https://codeforc.es/problemset/problem/1383/C)       |                       |      |
| 5    | [新年的复读机](https://uoj.ac/problem/497)                   | [Link](#table5)       | √    |
| 6    | [网络恢复](https://uoj.ac/problem/550)                       |                       |      |
| ※7   | [CF1019C](https://www.luogu.com.cn/problem/CF1019C)          | [Link](#table7)       | √    |
| ※8   | [Zombies](https://www.luogu.com.cn/problem/CF1832F)          | [Link](#table8)       | √    |
| ※9   | [HNOI2010 取石子游戏](https://www.luogu.com.cn/problem/P3210) | [Link](#table9)       | √    |
| ※10  | [[USACO19DEC] Tree Depth P](https://www.luogu.com.cn/problem/P5853) | [Link](#table10)      | √    |
| 11   | [Can Bash Save the Day?](https://www.luogu.com.cn/problem/CF757G) |                       |      |
| 12   | [[USACO20OPEN] Circus P](https://www.luogu.com.cn/problem/P6277) |                       |      |
| 13   | [[USACO21OPEN] Routing Schemes P](https://www.luogu.com.cn/problem/P7531) |                       | √    |
| 14   | [[USACO20OPEN] Exercise P](https://www.luogu.com.cn/problem/P6276) |                       | √    |
| ※15  | [[USACO19FEB] Moorio Kart P](https://www.luogu.com.cn/problem/P5243) | [Link](#table15)      | √    |
| 16   | [[USACO19OPEN] Compound Escape P](https://www.luogu.com.cn/problem/P5422) |                       | √    |
| 17   | [[USACO22FEB] Paint by Rectangles P](https://www.luogu.com.cn/problem/P8192) | 做法好猜，正确性未知  |      |
| 18   | [[USACO22FEB] Phone Numbers P](https://www.luogu.com.cn/problem/P8194) |                       | √    |
| 19   | [[USACO22OPEN] 262144 Revisited P](https://www.luogu.com.cn/problem/P8275) | AC & [Link](#table19) |      |
| 20   | [[USACO19FEB] Mowing Mischief P](https://www.luogu.com.cn/problem/P5244) |                       |      |
| ※21  | [TEST_125 tmostnrq](https://www.luogu.com.cn/problem/T318505) | [Link](#table21)      | √    |
| 22   | [Hidden Bipartite Graph](https://www.luogu.com.cn/problem/CF1033E) | AC & [Link](#table22) | √    |



### <a id="table5">5. 新年的复读机</a>

首先肯定有这么一个数，每次操作要么是把它和它左边的合并，要么把它和它右边合并。所以枚举这个数，然后它向两边 $dp$，然后发现，它前缀 $\gcd$ 和后缀 $\gcd$ 都是只有 $\log(a)$ 段，肯定每次是向左到段首或者段尾，这就 $O(\log^2)$ 了；实际上，设 $F_{l,k}$ 表示 $l$ 出发的 $k$ 个段，这一段的最小代价，同理设 $G_{r,k}$，这样就能把复杂度压到 $O(n\log n)$。

### <a id="table7">7. CF1019C</a>

首先，一个 DAG 可以做到任一点距离小等于 $1$；那么我们要把图划分成一个 DAG 和一个可以被 DAG 一步到达的点集，增量构造即可。

### <a id="table8">8. Zombies</a>

有几个切面可以思考：

1. **固定每组的电网怎么用，怎么分配豌豆？**那么每个豌豆要找到和它的中点和中点相差最小的一个电网，这样它们交集会尽可能小。
2. **假如只有一个电网，怎么确定电网的时间？**每个豌豆的贡献是一个分三段的一次函数，第一段斜率 $-1$，第二段斜率 $0$，第三段斜率 $1$，维护一个函数形状即可。

第一个事情告诉我们，把豌豆**按照中点排序，那么可以按顺序 dp**。事实上，可以 wqs 套 dp。

第二个事情给了我们求 $calc(l,r)$ 的方式，而我们要求出所有 $calc(l,r)$，这东西的决策点也满足决策单调性。

### <a id="table8">9. 取石子游戏</a>

首先：若 $a_{i-1}<a_i$ 且 $a_i>a_{i+1}$，那么这个位置 $i$ 就相当优秀，两个人都会去避免 $i-1,i+1$，最后先手顶不住了，不得不取了 $a_{i-1}$，那么后手取了 $a_i$，先手取了 $a_{i+1}$；那么这就相当于一个价值 $a_{i-1}+a_{i+1}-a_i$ 的石子。

于是所有序列只有单谷的情况了，可以直接把所有石子从大到小排序，两个人轮流选。

### <a id="table10">10. Tree Depth P</a>

首先考虑逆序对数为 $K$ 的排列数怎么求：相当于求一个物品为 $\{0\},\{0,1\},\cdots,\{0,1,\cdots,n-1\}$ 的多重 01 背包的方案数。

**树的深度也非常难限制，所以将其用期望的线性性进行转化：对每个 $u,v$，求出 $v$ 作为 $u$ 祖先的方案数**。然后发现我们先确定 $u\sim v-1$，再确定 $v$，再确定别的数，这就相当于把背包去掉了 $v-u$ 这个元素，仅此而已，于是做完了。

### <a id="table15">15. Moorio Kart P</a>

法一：**所有连通块大小的和为 $n$，这不禁让人想到自然根号**，对于大于 $n^{0.5}$ 的连通块，它至多有 $n^{0.5}$ 个；对于小于 $n^{0.5}$ 的连通块，它的代价为 $sz^2$，而 $\sum sz^2\le n^{0.5}\sum sz=n^{1.5}$。

法二：考虑 $dep+dep-2dep$，枚举了 $2dep$ 后，剩下两个 $dep$ 是独立的，那么可以**点分治**，然后**先后枚举**两个儿子，分别往背包里加即可。$O(n^2\log n)$。

法三：法二的枚举 $lca$ 是很废的事情，考虑 **up and down** 维护这件事情，设 $f_{u,i}$ 表示 $u$ 点上和为 $i$ 的方案数，向上转移一遍，再向下转移一遍，最后容斥掉 $lca$ 下方两个点相同的情况即可。$O(n^2)$。

### <a id="table19">19. 262144 Revisited P</a>

首先有一个区间 dp：设 $f_{l,r}$ 表示答案，利用决策单调性可以优化到 $O(n^2)$。

注意到对于 $[l,r]\subseteq [L,R]$，一定有 $f_{l,r}\le f_{L,R}$。所以考虑固定 $l$，考虑 $f_l(r)$ 作为分段常数函数它是怎么分段的。

首先 $f_{l}(l)=a_l$；然后设 $k_l(x)$ 是最大的位置使得 $f_l(k_l(x))\le x$，假设已经知道了 $k_l(a_l\sim x)$，怎么求出 $k_l(x+1)$？有转移式：
$$
k_{x+1}=\max_{i\in[a_l,x]} k_{k_l(i)+1}(x)
$$
但是，由于有 $f_{k_l(i)+1}(k_l(x)+1)\ge x$，所以发现用 $i<x$ 来转移是不优的，所以有：
$$
k_{x+1}=k_{k_l(x)+1}(x)
$$
直接用记忆化或者主席树来优化转移，会发现总状态数已经正确了，只是时间效率还是略低，会导致被卡常，获得 $91$ 分。以下为题解所述的进一步思路：

称 $[l,r]$ 为极大区间，当且仅当不存在 $[l,r]\subseteq[L,R]$ 使得 $f_{l,r}=f_{L,R}$，也即 $f_{l,r}<f_{l-1,r}$ 且 $f_{l,r}<f_{l,r+1}$。我们有：**极大区间的量级是 $O(n\log n)$** 的。证明：

设 $g(n)$ 表示长度为 $n$ 的区间的极大区间数量的最大值，设全局最大值位于 $p$ 位置，那么：
$$
g(n)\le g(p-1)+g(n-p)+h(n,p)
$$
$h(n,p)$ 表示长度为 $n$ 的序列，最大化跨过 $p$ 的极大区间数量。设 $f_{l,r}=a_{p+k}$ 的极大区间 $[l,r]$ 的数量为 $q(k)$，那么有：
$$
q(k)\le \min\left(2^k,p\right)
$$
求和可得：$h(n,p)\le p\log\frac np=\log\binom{n}{p}$，根据归纳法：$g(n)\le \log p+\log(n-p)+\log\binom{n}{p}=n\log n$ 证毕。

如上复杂度分析启发我们一个做法：维护区间集合 $[l,r]$ 表示所以极大的区间使得 $f_{l,r}\le v$（注意，和**极大区间**的定义不同哦），那么考虑 $v\rightarrow v+1$，它会将一些区间“合并”，再插入所有 $a_x=v+1$ 的位置，那么可以用双向链表维护，再用一个数组维护这次会发生变化的位置集合，注意到每次修改产生的新区间，一定是 $f_{l,r}=v+1$ 的**极大区间**，只要避免访问不需要变化的区间就可以做到总复杂度正确。

感觉 OI 在这方面的量级分析上不是很有直观。

### <a id="table21">21. TEST_125 tmostnrq</a>

根号做法：对操作序列分块，对每一块分别预处理树上的每个点它经过了这个块会到达哪里，预处理方式：建出这 $n^{0.5}$ 个点构成的虚树，对于虚树上的每一条边（也就是原树上的链），维护一个双端队列，队列的每个元素是当前在这个点上面的点集构成的链表；对于每一次操作，都只会进行 $n^{0.5}$ 次链表和队列的修改操作；而虚树外的点，都只会被在某个特定的时刻加入虚树。

双 $\log$ 做法：刚刚做法没有用上离线！在 $l$ 时间把点插进去，$r$ 时间再查查点跑到哪里了。树剖，剖完了每条重链上维护它上面的每个点，它上面的点集。除了当前操作的那个点位于的那 $\log n$ 个重链之外，其它的点都是向上移动，它最多会跳 $\log$ 次重链，只在它位于的重链发生变化时，提取出变化的那个点集对应的并查集向上归并，总的势能只有 $n\log n$；而当前重链上的点，可以一起向下移动，新产生的势能也只有 $\log n$。

### <a id="table22">22. CF1033E</a>

考虑维护一个当前的连通块，并且已知左部点为 $S_l$，右部点为 $S_r$，考虑怎么扩大这两个集合。

除了这个已知的连通块之外，假如我们还知道这张图的一些边，这些边把图分成了若干个连通块 $T_{1\sim k}$，维护循环指针 $pt_{1\sim k}$ 分别指向 $T_{1\sim k}$ 中的一个点。

不断进行如下操作，询问 $\{pt\}$ 点集内是否有边：

* 如果有：那么二分出这条边，使得 $k$ 下降一（称为**一操作**），合并两个集合，$pt$ 指向原本大的那个集合的 $pt$；

* 否则可以查 $\{pt\}\cup S_l$ 和 $\{pt\}\cup S_r$ 是否有边，如果有边：可以二分出是哪一条，这也会是 $k$ 至少下降一（称为二**操作**）。
* 否则：令 $pt_{1\sim k}$ 都自增 $1$（称为**无效操作**）。

无效操作什么都进行不了，这种情况下的势能证明如下：假如经历了若干次无效操作后，进行了二操作，那么 $|S_l|+|S_r|$ 的增量大等于此前无效操作数量，那么势能正确了；假如进行的是一操作，可以看作是不会影响别的 $T$ 的势能，只是会影响 $T_x$ 和 $T_y$ 两个集合的势能，可以把新指针指向其中较大的集合的原有指针，那么势能多花费的至多只有小集合的大小，符合启发式合并的分析，总的势能增量是 $n\log n$。

~~来自 Michael 的更为精确的证明：势能分析就是在说这样一件事：设 $T_1\sim T_k$ 中点数分别为 $siz_1\sim siz_k$，则在 $\min(siz_1,\cdots,siz_k)+1$ 次操作内，要么有连通块和当前连通块合并，要么有两个连通块合并（不对，不一定会有）。~~

应该这么表述，一个连通块 $T_x$，随着 $S_l$ 和 $S_r$ 的增大，它在某一时刻存在了一条连向 $S_l+S_r$ 的边，从这一时刻起，它至多经过 $|T_x|$ 次无效操作就会被合并进 $S_l+S_r$ 里；记势能为，所有已经有边连向 $S_l+S_r$ 的 $T_x$ 集合中，它的 $pt$ 还需要 $pt\leftarrow pt+1$ 几次，$pt$ 才会指向那个能连到 $S_l+S_r$ 的点。势能增加有两种情况：第一种是，随着 $S$ 增大，$T_x$ 开始和 $S_l+S_r$ 直接相连了，对势能增量为 $|T_x|$；第二种是合并了两个集合 $T_x+T_y$，那么把 $pt$ 指向其中大的那个的 $pt$，不妨设 $|T_x|\le |T_y|$，若 $T_y$ 直连 $S$，那么势能最多上升 $|T_x|$（也即 $\min\left(|T_x|,|T_y|\right)$，符合启发式合并的复杂度分析），否则若 $T_x$ 直连 $S$，则势能最多上升 $|T_y|$，而这种情况，每个叶子只会贡献到 $|T_y|$ 里至多一次；其余情况，势能一定会下降。